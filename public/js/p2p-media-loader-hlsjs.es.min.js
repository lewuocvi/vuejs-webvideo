var j = Object.defineProperty;
var R = (n) => {
  throw TypeError(n);
};
var q = (n, t, e) => t in n ? j(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e;
var a = (n, t, e) => q(n, typeof t != "symbol" ? t + "" : t, e), k = (n, t, e) => t.has(n) || R("Cannot " + e);
var i = (n, t, e) => (k(n, t, "read from private field"), e ? e.call(n) : t.get(n)), l = (n, t, e) => t.has(n) ? R("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), u = (n, t, e, s) => (k(n, t, "write to private field"), s ? s.call(n, e) : t.set(n, e), e), x = (n, t, e) => (k(n, t, "access private method"), e);
import { CoreRequestError as T, debug as N, Core as z } from "p2p-media-loader-core";
function F(n, t) {
  return t ? `${n}|${t.start}-${t.end}` : n;
}
function J(n, t) {
  if (n !== void 0 && t !== void 0 && n <= t) return { start: n, end: t };
}
var H, M, g, m, p, v, L, $, A;
class B {
  constructor(t, e) {
    l(this, L);
    a(this, "context");
    a(this, "config");
    a(this, "stats");
    l(this, H);
    l(this, M);
    l(this, g);
    l(this, m);
    l(this, p);
    l(this, v);
    u(this, m, e), u(this, M, () => new t.loader(t)), this.stats = { aborted: !1, chunkCount: 0, loading: { start: 0, first: 0, end: 0 }, buffering: { start: 0, first: 0, end: 0 }, parsing: { start: 0, end: 0 }, total: 1, loaded: 1, bwEstimate: 0, retry: 0 };
  }
  load(t, e, s) {
    this.context = t, this.config = e, u(this, H, s);
    const { stats: r } = this, { rangeStart: d, rangeEnd: o } = t, E = J(d, o !== void 0 ? o - 1 : void 0);
    u(this, v, F(t.url, E));
    const h = i(this, m).isSegmentLoadable(i(this, v));
    if (!i(this, m).hasSegment(i(this, v)) || !h) return u(this, g, i(this, M).call(this)), i(this, g).stats = this.stats, void i(this, g).load(t, e, s);
    i(this, m).loadSegment(i(this, v), { onSuccess: (f) => {
      u(this, p, f);
      const c = i(this, p).data.byteLength;
      r.loading = function(b, C, S) {
        const D = 8e3 * C / b, I = S - D;
        return { start: I - 10, first: I, end: S };
      }(i(this, p).bandwidth, c, performance.now()), r.total = c, r.loaded = c, s.onProgress && s.onProgress(this.stats, t, i(this, p).data, void 0), s.onSuccess({ data: i(this, p).data, url: t.url }, this.stats, t, void 0);
    }, onError: (f) => {
      f instanceof T && f.type === "aborted" && this.stats.aborted || x(this, L, $).call(this, f);
    } });
  }
  abort() {
    var t, e;
    i(this, g) ? i(this, g).abort() : (x(this, L, A).call(this), (e = (t = i(this, H)) == null ? void 0 : t.onAbort) == null || e.call(t, this.stats, this.context, {}));
  }
  destroy() {
    i(this, g) ? i(this, g).destroy() : (this.stats.aborted || x(this, L, A).call(this), u(this, H, null), this.config = null);
  }
}
H = new WeakMap(), M = new WeakMap(), g = new WeakMap(), m = new WeakMap(), p = new WeakMap(), v = new WeakMap(), L = new WeakSet(), $ = function(t) {
  var s;
  const e = { code: 0, text: "" };
  (t instanceof T && t.type === "failed" || t instanceof Error) && (e.text = t.message), (s = i(this, H)) == null || s.onError(e, this.context, null, this.stats);
}, A = function() {
  !i(this, p) && i(this, v) && (this.stats.aborted = !0, i(this, m).abortSegmentLoading(i(this, v)));
};
var y;
class X {
  constructor(t) {
    l(this, y);
    a(this, "context");
    a(this, "stats");
    u(this, y, new t.loader(t)), this.stats = i(this, y).stats, this.context = i(this, y).context;
  }
  load(t, e, s) {
    i(this, y).load(t, e, s);
  }
  abort() {
    i(this, y).abort();
  }
  destroy() {
    i(this, y).destroy();
  }
}
y = new WeakMap();
class K {
  constructor(t) {
    a(this, "core");
    this.core = t;
  }
  processMainManifest(t) {
    const { levels: e, audioTracks: s } = t;
    for (const [r, d] of e.entries()) {
      const { url: o } = d;
      this.core.addStreamIfNoneExists({ runtimeId: Array.isArray(o) ? o[0] : o, type: "main", index: r });
    }
    for (const [r, d] of s.entries()) {
      const { url: o } = d;
      this.core.addStreamIfNoneExists({ runtimeId: Array.isArray(o) ? o[0] : o, type: "secondary", index: r });
    }
  }
  updatePlaylist(t) {
    const { details: { url: e, fragments: s, live: r } } = t, d = this.core.getStream(e);
    if (!d) return;
    const o = new Set(d.segments.keys()), E = [];
    s.forEach((h, f) => {
      const { url: c, byteRange: b, sn: C, start: S, end: D } = h;
      if (C === "initSegment") return;
      const [I, w] = b, U = J(I, w !== void 0 ? w - 1 : void 0), P = F(c, U);
      o.delete(P), d.segments.has(P) || E.push({ runtimeId: P, url: c, externalId: r ? C : f, byteRange: U, startTime: S, endTime: D });
    }), (E.length || o.size) && this.core.updateStream(e, E, o.values());
  }
}
class G {
  constructor(t) {
    a(this, "core");
    a(this, "segmentManager");
    a(this, "hlsInstanceGetter");
    a(this, "currentHlsInstance");
    a(this, "debug", N("p2pml-hlsjs:engine"));
    a(this, "updateMediaElementEventHandlers", (t) => {
      var r;
      const e = (r = this.currentHlsInstance) == null ? void 0 : r.media;
      if (!e) return;
      const s = t === "register" ? "addEventListener" : "removeEventListener";
      e[s]("timeupdate", this.handlePlaybackUpdate), e[s]("seeking", this.handlePlaybackUpdate), e[s]("ratechange", this.handlePlaybackUpdate);
    });
    a(this, "handleManifestLoaded", (t, e) => {
      const s = e.networkDetails;
      s instanceof XMLHttpRequest ? this.core.setManifestResponseUrl(s.responseURL) : s instanceof Response && this.core.setManifestResponseUrl(s.url), this.segmentManager.processMainManifest(e);
    });
    a(this, "handleLevelSwitching", (t, e) => {
      e.bitrate && this.core.setActiveLevelBitrate(e.bitrate);
    });
    a(this, "handleLevelUpdated", (t, e) => {
      this.currentHlsInstance && e.details.live && e.details.fragments[0].type === "main" && !this.currentHlsInstance.userConfig.liveSyncDuration && !this.currentHlsInstance.userConfig.liveSyncDurationCount && e.details.fragments.length > 4 && this.updateLiveSyncDurationCount(e), this.core.setIsLive(e.details.live), this.segmentManager.updatePlaylist(e);
    });
    a(this, "handleMediaAttached", () => {
      this.updateMediaElementEventHandlers("register");
    });
    a(this, "handleMediaDetached", () => {
      this.updateMediaElementEventHandlers("unregister");
    });
    a(this, "handlePlaybackUpdate", (t) => {
      const e = t.target;
      this.core.updatePlayback(e.currentTime, e.playbackRate);
    });
    a(this, "destroyCore", () => this.core.destroy());
    a(this, "destroy", () => {
      this.destroyCore(), this.updateHlsEventsHandlers("unregister"), this.updateMediaElementEventHandlers("unregister"), this.currentHlsInstance = void 0;
    });
    this.core = new z(t == null ? void 0 : t.core), this.segmentManager = new K(this.core);
  }
  static injectMixin(t) {
    var s, r;
    return e = t, r = class extends e {
      constructor(...o) {
        var b;
        const E = o[0], { p2p: h, ...f } = E ?? {}, c = new G(h);
        super({ ...f, ...c.getConfigForHlsJs() });
        l(this, s);
        c.bindHls(this), u(this, s, c), (b = h == null ? void 0 : h.onHlsJsCreated) == null || b.call(h, this);
      }
      get p2pEngine() {
        return i(this, s);
      }
    }, s = new WeakMap(), r;
    var e;
  }
  addEventListener(t, e) {
    this.core.addEventListener(t, e);
  }
  removeEventListener(t, e) {
    this.core.removeEventListener(t, e);
  }
  getConfigForHlsJs() {
    return { fLoader: this.createFragmentLoaderClass(), pLoader: this.createPlaylistLoaderClass() };
  }
  getConfig() {
    return { core: this.core.getConfig() };
  }
  applyDynamicConfig(t) {
    t.core && this.core.applyDynamicConfig(t.core);
  }
  bindHls(t) {
    this.hlsInstanceGetter = typeof t == "function" ? t : () => t;
  }
  initHlsEvents() {
    var e;
    const t = (e = this.hlsInstanceGetter) == null ? void 0 : e.call(this);
    this.currentHlsInstance !== t && (this.currentHlsInstance && this.destroy(), this.currentHlsInstance = t, this.updateHlsEventsHandlers("register"), this.updateMediaElementEventHandlers("register"));
  }
  updateHlsEventsHandlers(t) {
    const e = this.currentHlsInstance;
    if (!e) return;
    const s = t === "register" ? "on" : "off";
    e[s]("hlsManifestLoaded", this.handleManifestLoaded), e[s]("hlsLevelSwitching", this.handleLevelSwitching), e[s]("hlsLevelUpdated", this.handleLevelUpdated), e[s]("hlsAudioTrackLoaded", this.handleLevelUpdated), e[s]("hlsDestroying", this.destroy), e[s]("hlsMediaAttaching", this.destroyCore), e[s]("hlsManifestLoading", this.destroyCore), e[s]("hlsMediaDetached", this.handleMediaDetached), e[s]("hlsMediaAttached", this.handleMediaAttached);
  }
  updateLiveSyncDurationCount(t) {
    const e = t.details.targetduration, s = Math.floor(120 / e), r = Math.min(t.details.fragments.length - 1, s);
    this.currentHlsInstance && this.currentHlsInstance.config.liveSyncDurationCount !== r && (this.debug(`Setting liveSyncDurationCount to ${r}`), this.currentHlsInstance.config.liveSyncDurationCount = r);
  }
  createFragmentLoaderClass() {
    const { core: t } = this, e = this;
    return class extends B {
      constructor(s) {
        super(s, t);
      }
      static getEngine() {
        return e;
      }
    };
  }
  createPlaylistLoaderClass() {
    const t = this;
    return class extends X {
      constructor(e) {
        super(e), t.initHlsEvents();
      }
    };
  }
}
export {
  G as HlsJsP2PEngine
};
//# sourceMappingURL=p2p-media-loader-hlsjs.es.min.js.map
